Para usar este proyecto en otra compu primero verificar si no tiene el error
de los emojis si no primero agregar las lineas correspondientes al appserviceprovider
descrito abajo luego crear una base de datos laradex_development
luego en el archivo .env poner lo correspondiente a la bbdd
y por ultimo
php artisan migrate
si al ingresar a la url salta un error de keys entonces
php artisan key:generate


Laravel utiliza composer para manejar sus depencias

composer create-project --prefer-dist laravel/laravel mi-proyecto// con esto creamos un proyecto de laravel

php artisan serve //comando para iniciar el servidor de desarrollo de laravel
php artisan list //lista todos los comandos de artisan
php artisan make:controller -h // nos dice que hace el comando

CONFIGURATION
1.ir a la ruta donde esta el proyecto luego
php artisan app:name <name_App> sirve para poner el nombre a nuestra aplicacion
2.Configurar el timezone
  ir a config/app.php
  y en ese archivo en la linea 'timezon'=>'UTC' cambiamos utc por America/Guatemala
3. Configurar el idioma
   ir a config/app.php
   y en ese archivo en la linea 'locale'=>'en' cambiamos en por es
   luego en la carpeta resources/lang creamos una carpeta llamada es 
   bajamos los archivos de lenguaje espa√±ol de git https://github.com/caouecs/Laravel-lang
   dentro de ese link de github en la carpeta src buscamos la carpeta es
   copiamos los cuatro archivos y los pegamos en nuestra carpeta es de nuestro proyecto

TEORIA HTTP
Es el protocolo de comunicacion que permite las tranferencias de informacion en la WWW.
http define una serie predefinida de metodos de peticion(verbos).

GET
Solicita una representacion dle recurso especificado.
POST
Envia los datos para que sean procesados por el recurso.
PUT/PATCH
Se utiliza para actualizar un recurso especificado
DELETE
Borra un recurso especificado

RUTAS
Para trabajar con las rutas nos vamos a 
routes/web.php //aca van las rutas de nuestro proyecto web

La sintaxis de una ruta en laravel es:

Route::<verbo_http>('/<nombre_ruta>',function(){
	return <cadena_o_view>;
});

La sintaxis de una ruta con parametros en laravel es:

Route::<verbo_http>('/<nombre_parametro>'/{<parametro>},function($parametro){
	return "<cadena_o_view>".$parametro;
});

Ejemplo

Route::get('/name/{name}/lastname/{lastname}',function($name,$lastname){
	return "Hola soy ".$name. " ".$lastname ;
});

para ingresar a esta ruta seria asi: http://localhost:8000/name/Eddy/lastname/Paz
una variacion es
Route::get('/name/{name}/lastname/{lastname?}',function($name,$lastname="apellido"){
	return "Hola soy ".$name. " ".$lastname ;
});
Lo anterior lo que hace es setear el apellido si no viene y con el signo ? indicamos que es opcional


CONTROLADORES
Podemos crear controladores de forma manual o utilizando artisan
Los controladores siempre deben tener un namespace para poder hacer referencia a ellos desde un router.
Por otro lado siempre deben extender de la clase Controller usando la la sentencia extends y use

Al llamar un metodos de un controlador desde un route se debe hacer de la siguiente manera
Route::get('prueba','PruebaController@prueba');
como primer argumento esta la ruta llamada prueba
y como segundo el nombre del controlador seguido de una arroba y el metodo que se quiere de ese controlador

Al llamar un metodo que requiere parametros de un controlador desde un route
Route::get('prueba/{name}','PruebaController@prueba');

TEORIA REST
Estilo arquitectonico para proporcionar estandares para sistemas informaticos que estan en la web.

RESTFULL
Endpoint que implementa rest

php artisan make:controller <name_controller> --resource//Crea controladores el --resource es opcional
Nota este controlador se crea en la carpeta Auth

Nota: las siguientes anotaciones de los controladores es acerca de como acceder a ellos si fueron creados con artisan.
Para acceder a todos los metodos de un controlador desde un route se utiliza la siguiente sintaxis
Route::resource('name_url','nameController');
Si quisieramos acceder desde un navegador a una funcion del controlador seria
http://ip/name_url/function
Route::resource('name_url','nameController.function')
 

VIEWS
resource/views
Se recomienda que por cada crud exista una carpeta dentro de views
Si vamos a lanzar una vista desde un controlador se hace de la siguiente manera
return view(name_carpeta.name_view);

Motor de plantillas BLADE
@yield('nombre_elemento') // contenidos variables dentro de html
@extends('nombre_o_ruta')//contenido que heredara la vista
@section('cualquier_elemento','parametros del elemento')//envia parametro(string) a un elemento ya sea heredado o propio
@section('nombre_elemento_declarado_con_yield')
contenido html
@endsection//nota esta seccion se diferencia del anterior que aca ira contenido mucho mas extenso y que el elemento
fue declarado con yield
@csrf//modulo de proteccion anti cross-site request forgery esto va inmediatamente despues de la etiqueta form
NOTA 1: para que el formulario sea capaz de enviar distintos tipos de datos o incluso archivos se le debe colocar el siguiente atrivuto a la etiqueta form: enctype="multipart/form-data"
NOTA 2: Los formulario de html no soportan la directiva put/patch por ello al igual que @csrf la directiva
@method('PUT') va despues de la etiqueta form
esto para hacer una peticion de actualizacion y el action del form no solo sera la ruta trainers que esta definida en el route si no tambien el slug
/trainers/{{$trainer->slug}}
REQUESTS
https://laravel.com/docs/5.8/controllers#restful-localizing-resource-uris
Si el controlador fue creado con artisan nos provee de una plantilla con todos los metodos y en la siguiente tabla
se muestra la forma de enviarlos al controlador dependiendo de la accion que se desea hacer
Verb  URI Action  Route Name
GET /photos index photos.index
GET /photos/create  create  photos.create
POST  /photos store photos.store
GET /photos/{photo} show  photos.show
GET /photos/{photo}/edit  edit  photos.edit
PUT/PATCH /photos/{photo} update  photos.update
DELETE  /photos/{photo} destroy photos.destroy

Para una mejor visualizacion ir a la url mostrad en el inicio

ELOQUENT ORM
Object Relational Mapping
Es una tecnica de programacion para convertir datos utilizando un lenguaje de programacion orientado
a objetos y la utilizacion de una base de datos relacional como motor de persistencia.

Eloquent proporciona una implementacion de ActiveRecord bella y sencilla para trabajar con nuestra base de datos.

Cada tabla tiene un "Modelo" correspondiente que se utiliza para interactuar con esa tabla.

Los modelos le permiten consultar datos en sus tablas, asi como insertar nuevos registros en la misma. 

Modelo: Es la representacion de la informacion. La tarea principal es gestionar la informacion de la bbdd.

MODELOS
php artisan make:model Trainer --migration
Al utilizar la etiqueta --migration lo que hace basicamente es crear tablas sin utilizar directamente sql
en la carpeta database/migrations aparecen los archivos de migraciones y en especifico aparece uno 
donde podemos crear nuestra tabla es facil identificarlo por que el nombre que tiene contiene el nombre del modelo
Nota: dichas migraciones(sentencias sql) se van a ejecutar en la bbdd que tengamos configurada en el archivo
.env
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laradex_development
DB_USERNAME=root
DB_PASSWORD=root

por ultimo ya que creamos los archivos de migraciones pero aun no hemos creado la bbdd 
entonces creamos la base de datos que tiene que tener el mismo nombre que le pusimos en el .env 
y luego colocamos 
php artisan migrate// este comando hara las migraciones a la bbdd


OPCIONAL(
Nota: puede dar error ya que laravel agrego el soporte para agregar emogis en la bbdd
entonces si utilizamos una version vieja de mysql debemos ir a la documentacion oficial para ver como se soluciona
en appserviceprovider.php
ponemos 
use Illuminate\Support\Facades\Schema;

y en el boot function
Schema::defaultStringLength(191);
)

NOTA: En los modelos debemos declarar una varible protegida llamada fillable en la cual la igualaremos a un vector con los campos que se pueden editar, 
protected $fillable=['name','avatar','description'] ;

AGREGAR CAMPO A TABLA EXISTENTE
Para agregar un campo a una tabla que ya existia es con 
php artisan make:migration add_avatar_to_trainer_table --table=trainers//esto lo que hace es crear un archivo
en database/migration/XXXXadd_avatar_to_trainer_table
que hara referencia a la tabla que vamos a modificar y es ahi donde colocamos el nuevo campo

$table->string('name_campo');


Para subir archivos al servidor en el metodo del controlador se debe colocar lo siguiente
if($request->hasFile('avatar')){//si existe un archivo con el nombre de input "avatar" entonces
  $file=$request->file('avatar');//se guarda en una variable el request indicandole que es un archivo
  $name=time().$file->getClientOriginalName();//se le pone un nombre unico para ello utilizamos el time
  $file->move(public_path())//movemos el archivo a 
  return $name;
}

AGREGAR CAMPO A TABLA TRAINER
php artisan make:migration add_description_to_trainer_table --table=trainers
luego nos dirijimos a database/migration/XXXXadd_description_to_trainer_table 
$table->string('name_campo');//en la funcion up existe una parte llamada Schema lo agregamos dentro
php artisan migrate

Implicit Binding
Resolver de manera automatica los modelos definidos en eloquent
en la funcion show de nuestros controladores en lugar de tener como parametro el $id podemos tener de parametro el modelo y la variable
Trainer $trainer
asi por ejemplo en el siguiente fragmento de codigo 
 public function show(Trainer $trainer)
{
   view('trainers.show',compact('trainer'));
}
NOTA: en el ejemplo anterior hay que mandarle el id desde las vista

SLUG
Basicamente el objetivo de slug es: NO MOSTRAR EL CONTENIDO DE VARIABLES PASADOS POR LA URL

PARA AGREGAR UN SLUG
Primero agregamos una migracion a una tabla
php artisan make:migration add_slug_to_trainers --table=trainers
Segundo despues de ejecutar artisan migration se crea un archivo en database/migrations/xxxxadd_slug_to_trainers
en la funcion up dentro del schema colocamos
$table->string('slug')->unique();
Tercero se ejecuta
php artisan migrate

NOTA: En todas las migraciones en los archivos de migraciones existe una funcion down y dentro del schema tenemos que colocar que debe realizar la migracion si hacemos rollback de la misma 
por ejemplo en la migracion anterior en la funcion down dentro de schema colocamos
$table->dropColumn('slug');
para que elimine la columna si hacemos rollback

luego de ello el slug pasaria a funcionar como si fuese el id, por tanto en todos los href donde pasemos un id ahora pasaremos un slug y en todos los controllers donde recibamos un id ahora ya no recibiremos un id si no mas bien un slug

Ahora uniendo ambos tanto slug como implicit binding podemos solo colocar unas lineas en el modelo para que funcionen ambos

   /**
   * Get the route key for the model.
   *
   * @return string
   */
  public function getRouteKeyName()
  {
      return 'slug';
  }

Con esto lo que hacemos es pasar el slug en la vista y en el controlador utilizamos el splicit binding 
es decir pasar como parametro un objeto de tipo entrenador, esto lo podemos hacer si en el modelo del trainer colocamos las lineas arriba mostradas